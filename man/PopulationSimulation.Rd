% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PopulationSimulation.R
\docType{class}
\name{PopulationSimulation}
\alias{PopulationSimulation}
\title{PopulationSimulation: simulating populations of tensor agents.}
\format{\code{\link{R6Class}} object.}
\usage{
PopulationSimulation
}
\value{
An object of class PopulationSimulation.

Object of \code{\link{PopulationSimulation}} with methods for drawing graphs according suitable for final version of the paper.
}
\description{
This R6 class defines functions for running agent-based simulations described in Ellison & Miceli (2017 - Language 93(2):255-287) - hereafter EM.
These simulations use the cognitive model
defined by the class TensorAgent in this package. The modelling works by setting the parameters using
auxiliary methods, then calling a \code{$simulate()} method to execute the simulation.
The simulation models a two-language community, with 2 monolingual populations and a bilingual community.
The sizes of each of these communities can be set by parameter. The language mode and monitoring level are
set globally in the simulation, applying to all individuals in the bilingual community (they have no effect
on the monolingual communities).
}
\details{
Graphs 10a,b,c in EM are based on simulations run using this class.
}
\section{Fields}{

\describe{
  \item{\code{LanguageMode}}{The parameter defining how likely agents are to generate potential (even if unrealised) intrusions from non-target langauges.
  Parameter takes values \eqn{[0,1]}, 0 if no chance of intrusions, 1 if 50\% chance of intrusion.}
  \item{\code{MonitoringLevel}}{The parameter defining how intensely agents monitor to avoid non-target language intrusions. Parameter takes values \eqn{[0,1]}, 0 if no monitoring takes place, 1 if all potential intrusions are blocked.}
  \item{\code{Population_A}}{The number of agents in population speaking only language A.}
  \item{\code{Population_B}}{The number of agents in population speaking only language B.}
  \item{\code{Population_AB}}{The number of agents in population speaking both languages: A and B.}
  \item{\code{Population}}{The total number of agents.}
  \item{\code{SamplesPerAgent}}{The amount of data collected from each agent to serve as inputs to other agents' lexical memory.}
  \item{\code{NumberOfGenerations}}{The number of generations. In this simulation process, one generation involves two steps: talking on inputs, and generating data according to the cognitive model which will be input for the next generation.}
}
}

\section{Methods}{

\describe{
  \item{\code{new()}}{Creates a new, empty \code{PopulationSimulation} object.}
  \item{\code{$setPopulationStructure(A=100,B=100,AB=0)}}{Sets the population levels for the 2 monolingual communities and the bilingual community.}
  \item{\code{$setLanguageMode(languageMode)}}{Sets the language mode field.}
  \item{\code{$setMonitoringLevel(monitoringLevel)}}{Sets the monitoring level field.}
  \item{\code{$setSamplesPerAgent(samplesPerAgent)}}{Sets the samples-per-agent field.}
  \item{\code{$setNumberOfGenerations(numberOfGenerations)}}{Sets the number of generations for the simulation.}
  \item{\code{$clearLexicon()}}{Empty the lexicons of all agents.}
  \item{\code{$constructDataTensor()}}{Initialises the tensor structures of each agent.}
  \item{\code{$make_p_f_st__bm()}}{Builds the probabilistic mapping from meanings and target languages to forms in each agent. This is a complete run of the TensorAgent simulation for each agent, based on the input distribution of language-meaning-form combinations.}
  \item{\code{$setLexicon(A_d=0.5,A_nA=0.5,A_nB=0.0,B_d=0.5,B_nA=0.0,B_nB=0.5)}}{Set the initial frequency associated with each form in each language. \code{A_d} is the doppel as it is in language A, \code{A_nA} is the non-doppel native to language A as it appears in A, \code{A_nB} is the non-doppel native to language B should it appear in A, \code{B_d} is the doppel in language B, \code{B_nA} is the non-doppel native to A if it appears in language B, \code{B_nB} is the non-doppel native to B as it appears in that language. Values for each of these can be any positive floating-point number.}
  \item{\code{$productionDistribution()}}{Aggregates the distribution over forms in each language.}
  \item{\code{$sampleFromDistribution(distribution,exact=FALSE)}}{Takes a sample from the given distribution. If \code{exact} is \code{TRUE} then the distribution extracted is exact distributional copy as opposed to a random sample.}
  \item{\code{$setDistribution(samples)}}{Sets the distribution over lexical items in each agent (call \code{$clearLexicon()} first).}
  \item{\code{$simulate(exact=FALSE)}}{Simulate for the specified number of generations, with the given parameter values, from a starting distribution of \code{A_d=0.55,A_nA=0.45,A_nB=0.0,B_d=0.5,B_nA=0.0,B_nB=0.5}.}
}
}

\examples{
library(bldR)
ps <- PopulationSimulation$new();
ps$setPopulationStructure(20,20,20);
ps$setNumberOfGenerations(10);
ps$setMonitoringLevel(1.0);
ps$setLanguageMode(0.54);
ps$setSamplesPerAgent(100);
ps$setLexicon();
ps$simulate(exact=FALSE);

}
\keyword{datasets}
